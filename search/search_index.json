{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Software Developing Guidelines (for Scientists) # (Last updated on 09.08.2020) This note summarizes coding guidelines described in two top-rated books for software developers (as of 2020): Code Complete and Clean Code . Additional resources with links to online sources are described in Online Resources. [More details to come]","title":"Home"},{"location":"#software_developing_guidelines_for_scientists","text":"(Last updated on 09.08.2020) This note summarizes coding guidelines described in two top-rated books for software developers (as of 2020): Code Complete and Clean Code . Additional resources with links to online sources are described in Online Resources. [More details to come]","title":"Software Developing Guidelines (for Scientists)"},{"location":"about/","text":"About #","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"clean_code/overview/","text":"Overview - Clean Code # [coming up]","title":"Overview"},{"location":"clean_code/overview/#overview_-_clean_code","text":"[coming up]","title":"Overview - Clean Code"},{"location":"code_complete/1_foundations/","text":"Laying the Foundations (Chapters 1 - 4) # 1. Measure Twice, Cut Once! # The Goal of Preparation: Risk Reduction # Code construction is like building a house, there are the stages of planning, construction, and testing/inspection . Poorly planned projects are costly not because of the material cost but because errors cause people time (e.g. moving a wall after construction; redoing the construction two or more times). Overarching goal of preparation is risk reduction ; the most common project risks in software development are poor requirements and poor project planning . Illustration: building a 3 foot tower (1 meters) takes 10 beer cans, a pair of steady hands and a level ground, but building a tower 10 times higher takes much more than just 10x more beer cans. Similarly, detailed planning is required for building code just like building a house or a sky-scraper. The level of planning and the approach could be different depending on the kind of building. Why are good prerequisites important? # High-quality software comes from attention to quality in all three phases. But attention to quality at beginning (requirement and architecture design) has greater influence on product quality than attention at the end, during system testing. It is much more costly (estimated ~20-100x) to change a requirement after construction than earlier, closer to the time of writing the requirements. So be sure the requirements are right before you start. Caution # However, do not over-engineer! Some projects are better sequential , and some are better iterative , where the requirements are revised at each development cycle according to user feedback. Choose the right model (or combination of) for your project. Even in the iterative case, nevertheless, specifying well-specified pre-requisites reduces cost of the current cycle. What if my environment allows no time for designing pre-requisites? -- Part of the job of a technical employee is to educate people around them (including their supervisors and teammates) about the software-development process ( so don't pretend you are coding while doing the design, or worse, skip it altogether ), including the importance of developing pre-requisites before constructing the code, and planning time for it. Checklist for good prerequisites # Requirements # Essential Describe inputs and outputs to the system (e.g. accuracy, range of values, format, frequency; source for inputs; destination for outputs). Put output formats in shared documentation. Specify all external software interfaces and all communication interfaces (e.g. protocols for error-checking, hand-shaking, communication.) List all the tasks the user want to perform. Specify data used in and output by each task . Optional (specify if needed): the expected response time from the user's point of view; other timing expectations, e.g. processing time, data-transfer rate, system throughput; minimum machine memory/free disk space; portability to other operating system; ability to handle changes in internal functionalities and external software interface; definition of success/failure, etc. Signs of good requirements (1) Each requirement can be tested; (2) requirements are not specifying a design; (3) possible changes to the requirements are specified along with how likely the changes are; (4) if all the requirements are satisfied, then the product is acceptable; (5) areas where it is impossible to specify the requirements before construction are noted; (6) no requirements are impossible to implement. Architecture # Main components: Describe clearly the overall organization of the program, including good architecture overview and justification. Provide motivations for all major decisions made. Define major building blocks, what each block is responsible for, and how they interface. Describe and justify critical classes ( use the 80/20 rule: specify 20% of the classes that make up 80% of the system's behavior ). Describe and justify data design. Establish technical feasibility of all parts of the system. Other: Describe how scalability can be achieved. Describe how it is designed to accommodate likely changes. Describe and justify possibly other aspects: I/O handling strategy, speed vs memory budgets for different components, error-handling strategy, security requirements, buy-vs-build decisions, how re-used code will be made to conform. Make sure the user interface is modularized so changes can be decoupled from the rest of the program. 2. Key Construction Decisions [Draft, to be polished] # Programming Languages # Choosing the right programming language is important. People coding in languages they are familiar with are ~3x more productive than as beginners. In general, programming in higher-level languages is more efficient for development. (ratio of statement number: 6 for python, 2.5 for C++, 2 for fortran, and 1 for C). Some languages are also more expressive than others. Beware that some may be able to \"program into the language\" instead of \"in a language\" (having the ability to think of a concept first and then to express it in a given language), while others may not be able to do so even having the most expressive language to use (because their thoughts are being limited by the way things are done in a particular language they are used to.) Programming Conventions # It is important to set the programming conventions before you start constructing (because it's nearly impossible to change afterward). Lower-level implementations need to reflect consistency with the higher-level design (integrity), and be internally consistent. Illustration: A great design for a painting can amount to a weird collage when its different parts are being done with impressionist/ modern/ crayon styles... Unified programming conventions means that there is less brain load on the programmers spending time in the code. Instead of spending time figuring out which variations that are results of arbitrary choice, they single out the meaningful variations much faster as a results and focus their attention on those. Checklist before you start constructing # Do you have a? # Procedure for naming/comments/functions/classes and other specific coding practices . (We recommend the Google style guide ; see also the summary on Clean Code upcoming on this website for general principles.) Procedure for Error handling ; convention for class interfaces ; standards for reused code; performance considerations? Integration procedure for checking in code into the master source. (We recommend using Git for version control, locking the master branch for releases only, and using the develop branch for intaking daily pull requests, where each pull request needs to be reviewed and approved by at least one person on the team, either by a peer or a supervisor, before being merged in.) Will you ... ? # Write unit tests? (Highly recommended.) Write down the test cases before coding? Write and perform integration tests before checking code in? (Recommended to setup automated continuous integration if you are working on a large system or working with more than one person on the code.) Do you have the tools for ? # Editing, refactoring, syntax checking? (We highly recommend using Visual Studio Code as your editor, where you can download a lintor for syntax checking of any language, you debug concurrently in a terminal while editing code all in one window, and work remotely on a cluster as if you were on your laptop. We also recommend unifying editing tools within the team as much as possible, since some editors have different auto-formatting conventions.)","title":"1. Laying The Foundations"},{"location":"code_complete/1_foundations/#laying_the_foundations_chapters_1_-_4","text":"","title":"Laying the Foundations (Chapters 1 - 4)"},{"location":"code_complete/1_foundations/#1_measure_twice_cut_once","text":"","title":"1. Measure Twice, Cut Once!"},{"location":"code_complete/1_foundations/#the_goal_of_preparation_risk_reduction","text":"Code construction is like building a house, there are the stages of planning, construction, and testing/inspection . Poorly planned projects are costly not because of the material cost but because errors cause people time (e.g. moving a wall after construction; redoing the construction two or more times). Overarching goal of preparation is risk reduction ; the most common project risks in software development are poor requirements and poor project planning . Illustration: building a 3 foot tower (1 meters) takes 10 beer cans, a pair of steady hands and a level ground, but building a tower 10 times higher takes much more than just 10x more beer cans. Similarly, detailed planning is required for building code just like building a house or a sky-scraper. The level of planning and the approach could be different depending on the kind of building.","title":"The Goal of Preparation: Risk Reduction"},{"location":"code_complete/1_foundations/#why_are_good_prerequisites_important","text":"High-quality software comes from attention to quality in all three phases. But attention to quality at beginning (requirement and architecture design) has greater influence on product quality than attention at the end, during system testing. It is much more costly (estimated ~20-100x) to change a requirement after construction than earlier, closer to the time of writing the requirements. So be sure the requirements are right before you start.","title":"Why are good prerequisites important?"},{"location":"code_complete/1_foundations/#caution","text":"However, do not over-engineer! Some projects are better sequential , and some are better iterative , where the requirements are revised at each development cycle according to user feedback. Choose the right model (or combination of) for your project. Even in the iterative case, nevertheless, specifying well-specified pre-requisites reduces cost of the current cycle. What if my environment allows no time for designing pre-requisites? -- Part of the job of a technical employee is to educate people around them (including their supervisors and teammates) about the software-development process ( so don't pretend you are coding while doing the design, or worse, skip it altogether ), including the importance of developing pre-requisites before constructing the code, and planning time for it.","title":"Caution"},{"location":"code_complete/1_foundations/#checklist_for_good_prerequisites","text":"","title":"Checklist for good prerequisites"},{"location":"code_complete/1_foundations/#requirements","text":"Essential Describe inputs and outputs to the system (e.g. accuracy, range of values, format, frequency; source for inputs; destination for outputs). Put output formats in shared documentation. Specify all external software interfaces and all communication interfaces (e.g. protocols for error-checking, hand-shaking, communication.) List all the tasks the user want to perform. Specify data used in and output by each task . Optional (specify if needed): the expected response time from the user's point of view; other timing expectations, e.g. processing time, data-transfer rate, system throughput; minimum machine memory/free disk space; portability to other operating system; ability to handle changes in internal functionalities and external software interface; definition of success/failure, etc. Signs of good requirements (1) Each requirement can be tested; (2) requirements are not specifying a design; (3) possible changes to the requirements are specified along with how likely the changes are; (4) if all the requirements are satisfied, then the product is acceptable; (5) areas where it is impossible to specify the requirements before construction are noted; (6) no requirements are impossible to implement.","title":"Requirements"},{"location":"code_complete/1_foundations/#architecture","text":"Main components: Describe clearly the overall organization of the program, including good architecture overview and justification. Provide motivations for all major decisions made. Define major building blocks, what each block is responsible for, and how they interface. Describe and justify critical classes ( use the 80/20 rule: specify 20% of the classes that make up 80% of the system's behavior ). Describe and justify data design. Establish technical feasibility of all parts of the system. Other: Describe how scalability can be achieved. Describe how it is designed to accommodate likely changes. Describe and justify possibly other aspects: I/O handling strategy, speed vs memory budgets for different components, error-handling strategy, security requirements, buy-vs-build decisions, how re-used code will be made to conform. Make sure the user interface is modularized so changes can be decoupled from the rest of the program.","title":"Architecture"},{"location":"code_complete/1_foundations/#2_key_construction_decisions_draft_to_be_polished","text":"","title":"2. Key Construction Decisions [Draft, to be polished]"},{"location":"code_complete/1_foundations/#programming_languages","text":"Choosing the right programming language is important. People coding in languages they are familiar with are ~3x more productive than as beginners. In general, programming in higher-level languages is more efficient for development. (ratio of statement number: 6 for python, 2.5 for C++, 2 for fortran, and 1 for C). Some languages are also more expressive than others. Beware that some may be able to \"program into the language\" instead of \"in a language\" (having the ability to think of a concept first and then to express it in a given language), while others may not be able to do so even having the most expressive language to use (because their thoughts are being limited by the way things are done in a particular language they are used to.)","title":"Programming Languages"},{"location":"code_complete/1_foundations/#programming_conventions","text":"It is important to set the programming conventions before you start constructing (because it's nearly impossible to change afterward). Lower-level implementations need to reflect consistency with the higher-level design (integrity), and be internally consistent. Illustration: A great design for a painting can amount to a weird collage when its different parts are being done with impressionist/ modern/ crayon styles... Unified programming conventions means that there is less brain load on the programmers spending time in the code. Instead of spending time figuring out which variations that are results of arbitrary choice, they single out the meaningful variations much faster as a results and focus their attention on those.","title":"Programming Conventions"},{"location":"code_complete/1_foundations/#checklist_before_you_start_constructing","text":"","title":"Checklist before you start constructing"},{"location":"code_complete/1_foundations/#do_you_have_a","text":"Procedure for naming/comments/functions/classes and other specific coding practices . (We recommend the Google style guide ; see also the summary on Clean Code upcoming on this website for general principles.) Procedure for Error handling ; convention for class interfaces ; standards for reused code; performance considerations? Integration procedure for checking in code into the master source. (We recommend using Git for version control, locking the master branch for releases only, and using the develop branch for intaking daily pull requests, where each pull request needs to be reviewed and approved by at least one person on the team, either by a peer or a supervisor, before being merged in.)","title":"Do you have a?"},{"location":"code_complete/1_foundations/#will_you","text":"Write unit tests? (Highly recommended.) Write down the test cases before coding? Write and perform integration tests before checking code in? (Recommended to setup automated continuous integration if you are working on a large system or working with more than one person on the code.)","title":"Will you ... ?"},{"location":"code_complete/1_foundations/#do_you_have_the_tools_for","text":"Editing, refactoring, syntax checking? (We highly recommend using Visual Studio Code as your editor, where you can download a lintor for syntax checking of any language, you debug concurrently in a terminal while editing code all in one window, and work remotely on a cluster as if you were on your laptop. We also recommend unifying editing tools within the team as much as possible, since some editors have different auto-formatting conventions.)","title":"Do you have the tools for ?"},{"location":"code_complete/2_high_quality_code/","text":"Creating High Quality Code (Chapters 5 - X) # Managing Complexities # The primary causes of software project failures reported in surveys are rarely technical. They are mostly poor requirements, planning or management. But when they do fail for mainly technical reasons, the primary culprit is uncontrolled complexity . Managing complexities is one of the most, if not the most important technical topic in software development. No one's brain is big enough to contain an entire computer program. So one should not try to cram it all into one brain, but aim to organize the programs in such a way that we can safely focus on one part of it at a time. To minimize the amount of program you have to think about at once, we break big pieces into smaller ones . For example: make code modular (the more the different components are independent the more one can focus on it one at a time); keep routines short, write programs in the problem domain, work at the highest level of abstraction. In sum, those who compensate for the fact that humans can hold only a few things in the brain at once , will make code that's easier for themselves and others to understand and reduce errors. Design Principles # How hard is it to work in your code? Minimal Complexity - Avoid \"clever\" designs; choose \"simple\", \"easy-to-understand\" ones. Your design should let you safely ignore most parts of the program while focusing on a specific part. Ease of Maintenance - Design it for the maintenance programmer (possibly yourself in a few years). Continually ask yourself what maintenance programmer would ask you when they try to maintain the code. Make the design self-explanatory. How easy is it to test/extend/resuse your code? Loose coupling - Least possible connections among different parts of the program (e.g. classes have few interconnections between them). This benefits integration/ testing/ maintenance. Extensibility - You can enhance the system without shaking its whole structure (e.g. it's safe to change one piece of a system without affecting many others). Reusability - You can reuse pieces of the code in other systems. How efficient is your code's internal organization? High fan-in - A class is being used by many other classes, e.g. lower-level utility classes. The same applies to functions. Low-to-medium fan-out - Each class uses only a few other classes (about <7); otherwise, it's an indication that the class is too complex). The same applies to functions. Leanness - Voltaire: \"a book is finished not when nothing more can be added but when nothing more can be taken away.\" Be careful, extra code needs to be written/ reviewed/ tested/ considered when other code is changed -- it's not for free. How welcoming is your code to others? Stratification - You can view each level of decomposition without dipping into other levels. For example, if your code uses older and poorly designed code, write new classes to interface with it, so all other parts of the system just use these new classes. This way, you can 1) compartmentalize messy code, and 2) modify only the interface when the old code is to be replaced or improved. Standard Techniques - Use less exotic pieces since it can be intimidating for others trying to understand it. Cultivate a familiar feeling by using standard and common techniques. Portability - You can easily move it to another environment.","title":"2. Creating High-Quality Code"},{"location":"code_complete/2_high_quality_code/#creating_high_quality_code_chapters_5_-_x","text":"","title":"Creating High Quality Code (Chapters 5 - X)"},{"location":"code_complete/2_high_quality_code/#managing_complexities","text":"The primary causes of software project failures reported in surveys are rarely technical. They are mostly poor requirements, planning or management. But when they do fail for mainly technical reasons, the primary culprit is uncontrolled complexity . Managing complexities is one of the most, if not the most important technical topic in software development. No one's brain is big enough to contain an entire computer program. So one should not try to cram it all into one brain, but aim to organize the programs in such a way that we can safely focus on one part of it at a time. To minimize the amount of program you have to think about at once, we break big pieces into smaller ones . For example: make code modular (the more the different components are independent the more one can focus on it one at a time); keep routines short, write programs in the problem domain, work at the highest level of abstraction. In sum, those who compensate for the fact that humans can hold only a few things in the brain at once , will make code that's easier for themselves and others to understand and reduce errors.","title":"Managing Complexities"},{"location":"code_complete/2_high_quality_code/#design_principles","text":"How hard is it to work in your code? Minimal Complexity - Avoid \"clever\" designs; choose \"simple\", \"easy-to-understand\" ones. Your design should let you safely ignore most parts of the program while focusing on a specific part. Ease of Maintenance - Design it for the maintenance programmer (possibly yourself in a few years). Continually ask yourself what maintenance programmer would ask you when they try to maintain the code. Make the design self-explanatory. How easy is it to test/extend/resuse your code? Loose coupling - Least possible connections among different parts of the program (e.g. classes have few interconnections between them). This benefits integration/ testing/ maintenance. Extensibility - You can enhance the system without shaking its whole structure (e.g. it's safe to change one piece of a system without affecting many others). Reusability - You can reuse pieces of the code in other systems. How efficient is your code's internal organization? High fan-in - A class is being used by many other classes, e.g. lower-level utility classes. The same applies to functions. Low-to-medium fan-out - Each class uses only a few other classes (about <7); otherwise, it's an indication that the class is too complex). The same applies to functions. Leanness - Voltaire: \"a book is finished not when nothing more can be added but when nothing more can be taken away.\" Be careful, extra code needs to be written/ reviewed/ tested/ considered when other code is changed -- it's not for free. How welcoming is your code to others? Stratification - You can view each level of decomposition without dipping into other levels. For example, if your code uses older and poorly designed code, write new classes to interface with it, so all other parts of the system just use these new classes. This way, you can 1) compartmentalize messy code, and 2) modify only the interface when the old code is to be replaced or improved. Standard Techniques - Use less exotic pieces since it can be intimidating for others trying to understand it. Cultivate a familiar feeling by using standard and common techniques. Portability - You can easily move it to another environment.","title":"Design Principles"},{"location":"online_resources/tools/","text":"Developer Tools # Version control: Github (your best friend) Editor: Visual Studio Code Virtual environment: conda env or virtualenv Working on a cluster Reproducibility: python package Docker [More details to come.]","title":"Developer Tools"},{"location":"online_resources/tools/#developer_tools","text":"Version control: Github (your best friend) Editor: Visual Studio Code Virtual environment: conda env or virtualenv Working on a cluster Reproducibility: python package Docker [More details to come.]","title":"Developer Tools"}]}